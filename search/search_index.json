{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"An Interface of Our Own","text":""},{"location":"#what-is-this","title":"What is this?","text":"<p>An unofficial API for the Archive of Our Own, written in Kotlin for the JVM and Android.</p> <p>This project is not sanctioned by the Archive of Our Own, and should not be treated as such.</p>"},{"location":"#what-can-it-do","title":"What can it do?","text":"<ul> <li>Retrieve works</li> <li>Browse works by tag</li> <li>Browse bookmarks by tag</li> <li>Browse collections</li> <li>Search autocomplete results</li> <li>Login to AO3</li> </ul>"},{"location":"getting-started/initialisation/","title":"Initialising the service","text":"<p>Initialise the service using the default <code>AO3Service.create()</code> factory method  like so:</p> <pre><code>val service = AO3Service.create()\n</code></pre> <p>You can also configure the base url used by retrofit as shown below, in case  you wish to use okhttp's <code>MockWebServer</code> or anything similar.</p> <pre><code>val service = AO3Service.create(baseUrl = \"&lt;Your URL here&gt;\")\n</code></pre> <p>If you have an existing <code>OkHttpClient</code> instance, you can pass it to the method  like so. A new client will be created from it that shares the same resources with  the original client, with all the necessary configurations made. This new client  will be used by the service, and the old client may be used by your application  as per normal.</p> <pre><code>val service = AO3Service.create(okHttpClient = existingOkHttpClient)\n</code></pre> <p>Additional interceptors, converter factories, and call adapter factories can be  passed to the method as lists. They will be added to the retrofit instance  during initialisation.</p> <pre><code>val service = AO3Service.create(interceptors = listOf(interceptor1, interceptor2),\n                                converterFactories = listOf(factory1, factory2),\n                                callAdapterFactories = listOf(callAdapterFactory))\n</code></pre>"},{"location":"getting-started/installation/","title":"Installation","text":"<p>InterfaceOfOurOwn is distributed via Jitpack only. Include jitpack as a source repo like so:</p> Groovy (build.gradle)Kotlin DSL (build.gradle.kts) <pre><code>allprojects {\n    repositories {\n        // ...\n        maven { url \"https://jitpack.io\" }\n    }\n}\n</code></pre> <pre><code>allprojects {\n    repositories {\n        // ...\n        maven { setUrl(\"https://jitpack.io\") }\n    }\n}\n</code></pre> <p>Then add the dependency to your module's buildscript like so:</p> Groovy (build.gradle)Kotlin DSL (build.gradle.kts) <pre><code>implementation 'com.github.soblemprolved:interfaceofourown:0.3.0'\n</code></pre> <pre><code>implementation(\"com.github.soblemprolved:interfaceofourown:0.3.0\")\n</code></pre> <p>And that's it! You're good to go.</p>"},{"location":"getting-started/response-handling/","title":"Response Handling","text":"<p>The results of all methods in <code>AO3Service</code> are wrapped in an <code>AO3Response</code>, before being returned to the caller. This is done to make error handling easier, as we can handle them programmatically using <code>when</code> statements instead of try-catch statements, which improves readability in your code. An <code>AO3Response</code> can either be a <code>Success</code> or a <code>Failure</code>.</p>"},{"location":"getting-started/response-handling/#success","title":"Success","text":"<p>A <code>Success</code> represents a response from the server that successfully fulfills the request. It holds the result in its <code>value</code> field.</p> <p>We will examine how to process a <code>Success</code> below when retrieving a <code>Work</code> from the Archive. First, we make the network call like so.</p> <pre><code>val workResponse: AO3Response&lt;WorkConverter.Result&gt; = viewModelScope.launch { service.getWork(id = 12345) }\n</code></pre> <p>Next, we will check if the response is a <code>Success</code>, and specify programme behaviour to handle the result in the event of a <code>Success</code>.</p> <pre><code>when (workResponse) {\n    is Success -&gt; {\n        val (work, csrf) = workResponse.value\n        // Perform your own processing on the work below\n        when (work) {\n            is SingleChapterWork -&gt; // this is a oneshot\n            is MultiChapterOrIncompleteWork -&gt; // this is a multi-chapter/incomplete work\n        }\n        // Use the CSRF token to comment, give kudos, and login.\n    }\n    is Failure -&gt; ... // continued in Error Handling\n}\n</code></pre> <p>Note that destructuring declarations are used in lieu of <code>WorkConverter.Result</code> for ease of readability. The return types differ for all functions in the interface, so be sure to read the API reference for each return type.</p>"},{"location":"getting-started/response-handling/#failure","title":"Failure","text":"<p>A <code>Failure</code> is returned when the operation is unsuccessful (i.e. the request cannot be fulfilled for some reason). It encapsulates the error encountered in its <code>error</code> field as one of the subtypes of <code>AO3Error</code>.</p> <p>We show an example of how to process a <code>Failure</code> in the context of retrieving a <code>Work</code> from the Archive below. The process is the same for other operations, albeit with different types of errors for different operations.</p> <pre><code>// continued from above\nis Failure -&gt; {\n    when (response.error) {\n        is ConnectionError -&gt; // retry\n        is NotFoundError -&gt; // handle 404\n        is NotLoggedInError -&gt; // prompt user for login\n        // etc...\n        else -&gt; // use some generic error handling strategy\n    }\n}\n</code></pre>"},{"location":"recipes/browse-bookmarks-under-tag/","title":"Browsing bookmarks by tag","text":""}]}